{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.offsetToPosition = offsetToPosition;\nexports.locToRange = locToRange;\nexports.Position = exports.Range = void 0;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n *  Copyright (c) 2019 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n\nvar Range =\n/*#__PURE__*/\nfunction () {\n  function Range(start, end) {\n    var _this = this;\n\n    _classCallCheck(this, Range);\n\n    _defineProperty(this, \"start\", void 0);\n\n    _defineProperty(this, \"end\", void 0);\n\n    _defineProperty(this, \"containsPosition\", function (position) {\n      if (_this.start.line === position.line) {\n        return _this.start.character <= position.character;\n      } else if (_this.end.line === position.line) {\n        return _this.end.character >= position.character;\n      } else {\n        return _this.start.line <= position.line && _this.end.line >= position.line;\n      }\n    });\n\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(Range, [{\n    key: \"setStart\",\n    value: function setStart(line, character) {\n      this.start = new Position(line, character);\n    }\n  }, {\n    key: \"setEnd\",\n    value: function setEnd(line, character) {\n      this.end = new Position(line, character);\n    }\n  }]);\n\n  return Range;\n}();\n\nexports.Range = Range;\n\nvar Position =\n/*#__PURE__*/\nfunction () {\n  function Position(line, character) {\n    var _this2 = this;\n\n    _classCallCheck(this, Position);\n\n    _defineProperty(this, \"line\", void 0);\n\n    _defineProperty(this, \"character\", void 0);\n\n    _defineProperty(this, \"lessThanOrEqualTo\", function (position) {\n      return _this2.line < position.line || _this2.line === position.line && _this2.character <= position.character;\n    });\n\n    this.line = line;\n    this.character = character;\n  }\n\n  _createClass(Position, [{\n    key: \"setLine\",\n    value: function setLine(line) {\n      this.line = line;\n    }\n  }, {\n    key: \"setCharacter\",\n    value: function setCharacter(character) {\n      this.character = character;\n    }\n  }]);\n\n  return Position;\n}();\n\nexports.Position = Position;\n\nfunction offsetToPosition(text, loc) {\n  var EOL = '\\n';\n  var buf = text.slice(0, loc);\n  var lines = buf.split(EOL).length - 1;\n  var lastLineIndex = buf.lastIndexOf(EOL);\n  return new Position(lines, loc - lastLineIndex - 1);\n}\n\nfunction locToRange(text, loc) {\n  var start = offsetToPosition(text, loc.start);\n  var end = offsetToPosition(text, loc.end);\n  return new Range(start, end);\n}","map":null,"metadata":{},"sourceType":"script"}
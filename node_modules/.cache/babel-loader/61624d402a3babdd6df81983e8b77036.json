{"ast":null,"code":"import { extendError } from \"./extend-error\";\nconst onoConstructor = Ono;\nconst onoSingleton = Ono(Error);\nexport { onoConstructor as Ono, onoSingleton as ono };\n/**\n * Creates an `Ono` instance for a specifc error type.\n */\n\nfunction Ono(klass) {\n  // tslint:disable-next-line: no-shadowed-variable\n  return function ono(...args) {\n    let originalError;\n    let props;\n    let formatArgs;\n    let formattedMessage = \"\"; // Determine which arguments were actually specified\n\n    if (typeof args[0] === \"string\") {\n      formatArgs = args;\n    } else if (typeof args[1] === \"string\") {\n      if (args[0] instanceof Error) {\n        originalError = args[0];\n      } else {\n        props = args[0];\n      }\n\n      formatArgs = args.slice(1);\n    } else {\n      originalError = args[0];\n      props = args[1];\n      formatArgs = args.slice(2);\n    } // If there are any format arguments, then format the error message\n\n\n    if (formatArgs.length > 0) {\n      formattedMessage = onoSingleton.formatter.apply(undefined, formatArgs);\n    }\n\n    if (originalError && originalError.message) {\n      // The inner-error's message will be added to the new message\n      formattedMessage += (formattedMessage ? \" \\n\" : \"\") + originalError.message;\n    } // @ts-ignore\n    // Create the new error\n    // NOTE: DON'T move this line to a separate function! We don't want to pollute the stack trace\n\n\n    let newError = new klass(formattedMessage); // Extend the error with the properties of the original error and the `props` object\n\n    extendError(newError, originalError, props);\n    return newError;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
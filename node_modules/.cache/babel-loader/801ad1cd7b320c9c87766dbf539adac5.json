{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateWithCustomRules = validateWithCustomRules;\n\nvar _graphql = require(\"graphql\");\n/**\n *  Copyright (c) 2019 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n/**\n * Validate a GraphQL Document optionally with custom validation rules.\n */\n\n\nfunction validateWithCustomRules(schema, ast, customRules, isRelayCompatMode) {\n  // Because every fragment is considered for determing model subsets that may\n  // be used anywhere in the codebase they're all technically \"used\" by clients\n  // of graphql-data. So we remove this rule from the validators.\n  var _require = require('graphql/validation/rules/NoUnusedFragments'),\n      NoUnusedFragments = _require.NoUnusedFragments;\n\n  var _require2 = require('graphql/validation/rules/ExecutableDefinitions'),\n      ExecutableDefinitions = _require2.ExecutableDefinitions;\n\n  var rulesToSkip = [NoUnusedFragments, ExecutableDefinitions];\n\n  if (isRelayCompatMode) {\n    var _require3 = require('graphql/validation/rules/KnownFragmentNames'),\n        KnownFragmentNames = _require3.KnownFragmentNames;\n\n    rulesToSkip.push(KnownFragmentNames);\n  }\n\n  var rules = _graphql.specifiedRules.filter(function (rule) {\n    return !rulesToSkip.some(function (r) {\n      return r === rule;\n    });\n  });\n\n  var typeInfo = new _graphql.TypeInfo(schema);\n\n  if (customRules) {\n    Array.prototype.push.apply(rules, customRules);\n  }\n\n  var errors = (0, _graphql.validate)(schema, ast, rules, typeInfo);\n\n  if (errors.length > 0) {\n    return errors.filter(function (error) {\n      if (error.message.indexOf('Unknown directive') === -1) {\n        return true;\n      }\n\n      return !(error.nodes && error.nodes[0] && error.nodes[0].name && error.nodes[0].name.value === 'arguments' || error.nodes && error.nodes[0] && error.nodes[0].name && error.nodes[0].name.value && error.nodes[0].name.value === 'argumentDefinitions');\n    });\n  }\n\n  return [];\n}","map":null,"metadata":{},"sourceType":"script"}
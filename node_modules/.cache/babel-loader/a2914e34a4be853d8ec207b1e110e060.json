{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/revanthpobala/IdeaProjects/swagger-to-graphql-web/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefinitionQueryResultForNamedType = getDefinitionQueryResultForNamedType;\nexports.getDefinitionQueryResultForFragmentSpread = getDefinitionQueryResultForFragmentSpread;\nexports.getDefinitionQueryResultForDefinitionNode = getDefinitionQueryResultForDefinitionNode;\nexports.LANGUAGE = void 0;\n\nvar _graphqlLanguageServiceUtils = require(\"graphql-language-service-utils\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar LANGUAGE = 'GraphQL';\nexports.LANGUAGE = LANGUAGE;\n\nfunction getRange(text, node) {\n  var location = node.loc;\n  (0, _assert[\"default\"])(location, 'Expected ASTNode to have a location.');\n  return (0, _graphqlLanguageServiceUtils.locToRange)(text, location);\n}\n\nfunction getPosition(text, node) {\n  var location = node.loc;\n  (0, _assert[\"default\"])(location, 'Expected ASTNode to have a location.');\n  return (0, _graphqlLanguageServiceUtils.offsetToPosition)(text, location.start);\n}\n\nfunction getDefinitionQueryResultForNamedType(_x, _x2, _x3) {\n  return _getDefinitionQueryResultForNamedType.apply(this, arguments);\n}\n\nfunction _getDefinitionQueryResultForNamedType() {\n  _getDefinitionQueryResultForNamedType = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(text, node, dependencies) {\n    var name, defNodes, definitions;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            name = node.name.value;\n            defNodes = dependencies.filter(function (_ref) {\n              var definition = _ref.definition;\n              return definition.name && definition.name.value === name;\n            });\n\n            if (!(defNodes.length === 0)) {\n              _context.next = 5;\n              break;\n            }\n\n            process.stderr.write(\"Definition not found for GraphQL type \".concat(name));\n            return _context.abrupt(\"return\", {\n              queryRange: [],\n              definitions: []\n            });\n\n          case 5:\n            definitions = defNodes.map(function (_ref2) {\n              var filePath = _ref2.filePath,\n                  content = _ref2.content,\n                  definition = _ref2.definition;\n              return getDefinitionForNodeDefinition(filePath || '', content, definition);\n            });\n            return _context.abrupt(\"return\", {\n              definitions: definitions,\n              queryRange: definitions.map(function (_) {\n                return getRange(text, node);\n              })\n            });\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getDefinitionQueryResultForNamedType.apply(this, arguments);\n}\n\nfunction getDefinitionQueryResultForFragmentSpread(_x4, _x5, _x6) {\n  return _getDefinitionQueryResultForFragmentSpread.apply(this, arguments);\n}\n\nfunction _getDefinitionQueryResultForFragmentSpread() {\n  _getDefinitionQueryResultForFragmentSpread = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(text, fragment, dependencies) {\n    var name, defNodes, definitions;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            name = fragment.name.value;\n            defNodes = dependencies.filter(function (_ref3) {\n              var definition = _ref3.definition;\n              return definition.name.value === name;\n            });\n\n            if (!(defNodes.length === 0)) {\n              _context2.next = 5;\n              break;\n            }\n\n            process.stderr.write(\"Definition not found for GraphQL fragment \".concat(name));\n            return _context2.abrupt(\"return\", {\n              queryRange: [],\n              definitions: []\n            });\n\n          case 5:\n            definitions = defNodes.map(function (_ref4) {\n              var filePath = _ref4.filePath,\n                  content = _ref4.content,\n                  definition = _ref4.definition;\n              return getDefinitionForFragmentDefinition(filePath || '', content, definition);\n            });\n            return _context2.abrupt(\"return\", {\n              definitions: definitions,\n              queryRange: definitions.map(function (_) {\n                return getRange(text, fragment);\n              })\n            });\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getDefinitionQueryResultForFragmentSpread.apply(this, arguments);\n}\n\nfunction getDefinitionQueryResultForDefinitionNode(path, text, definition) {\n  return {\n    definitions: [getDefinitionForFragmentDefinition(path, text, definition)],\n    queryRange: definition.name ? [getRange(text, definition.name)] : []\n  };\n}\n\nfunction getDefinitionForFragmentDefinition(path, text, definition) {\n  var name = definition.name;\n  (0, _assert[\"default\"])(name, 'Expected ASTNode to have a Name.');\n  return {\n    path: path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    // This is a file inside the project root, good enough for now\n    projectRoot: path\n  };\n}\n\nfunction getDefinitionForNodeDefinition(path, text, definition) {\n  var name = definition.name;\n  (0, _assert[\"default\"])(name, 'Expected ASTNode to have a Name.');\n  return {\n    path: path,\n    position: getPosition(text, definition),\n    range: getRange(text, definition),\n    name: name.value || '',\n    language: LANGUAGE,\n    // This is a file inside the project root, good enough for now\n    projectRoot: path\n  };\n}","map":null,"metadata":{},"sourceType":"script"}
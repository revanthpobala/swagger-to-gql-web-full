{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = jsonParse;\n/**\n *  Copyright (c) 2019 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\n/**\n * This JSON parser simply walks the input, generating an AST. Use this in lieu\n * of JSON.parse if you need character offset parse errors and an AST parse tree\n * with location information.\n *\n * If an error is encountered, a SyntaxError will be thrown, with properties:\n *\n *   - message: string\n *   - start: int - the start inclusive offset of the syntax error\n *   - end: int - the end exclusive offset of the syntax error\n *\n */\n\nfunction jsonParse(str) {\n  string = str;\n  strLen = str.length;\n  start = end = lastEnd = -1;\n  ch();\n  lex();\n  var ast = parseObj();\n  expect('EOF');\n  return ast;\n}\n\nvar string;\nvar strLen;\nvar start;\nvar end;\nvar lastEnd;\nvar code;\nvar kind;\n\nfunction parseObj() {\n  var nodeStart = start;\n  var members = [];\n  expect('{');\n\n  if (!skip('}')) {\n    do {\n      members.push(parseMember());\n    } while (skip(','));\n\n    expect('}');\n  }\n\n  return {\n    kind: 'Object',\n    start: nodeStart,\n    end: lastEnd,\n    members: members\n  };\n}\n\nfunction parseMember() {\n  var nodeStart = start;\n  var key = kind === 'String' ? curToken() : null;\n  expect('String');\n  expect(':');\n  var value = parseVal();\n  return {\n    kind: 'Member',\n    start: nodeStart,\n    end: lastEnd,\n    key: key,\n    value: value\n  };\n}\n\nfunction parseArr() {\n  var nodeStart = start;\n  var values = [];\n  expect('[');\n\n  if (!skip(']')) {\n    do {\n      values.push(parseVal());\n    } while (skip(','));\n\n    expect(']');\n  }\n\n  return {\n    kind: 'Array',\n    start: nodeStart,\n    end: lastEnd,\n    values: values\n  };\n}\n\nfunction parseVal() {\n  switch (kind) {\n    case '[':\n      return parseArr();\n\n    case '{':\n      return parseObj();\n\n    case 'String':\n    case 'Number':\n    case 'Boolean':\n    case 'Null':\n      var token = curToken();\n      lex();\n      return token;\n  }\n\n  return expect('Value');\n}\n\nfunction curToken() {\n  return {\n    kind: kind,\n    start: start,\n    end: end,\n    value: JSON.parse(string.slice(start, end))\n  };\n}\n\nfunction expect(str) {\n  if (kind === str) {\n    lex();\n    return;\n  }\n\n  var found;\n\n  if (kind === 'EOF') {\n    found = '[end of file]';\n  } else if (end - start > 1) {\n    found = '`' + string.slice(start, end) + '`';\n  } else {\n    var match = string.slice(start).match(/^.+?\\b/);\n    found = '`' + (match ? match[0] : string[start]) + '`';\n  }\n\n  throw syntaxError(\"Expected \".concat(str, \" but found \").concat(found, \".\"));\n}\n\nfunction syntaxError(message) {\n  return {\n    message: message,\n    start: start,\n    end: end\n  };\n}\n\nfunction skip(k) {\n  if (kind === k) {\n    lex();\n    return true;\n  }\n}\n\nfunction ch() {\n  if (end < strLen) {\n    end++;\n    code = end === strLen ? 0 : string.charCodeAt(end);\n  }\n}\n\nfunction lex() {\n  lastEnd = end;\n\n  while (code === 9 || code === 10 || code === 13 || code === 32) {\n    ch();\n  }\n\n  if (code === 0) {\n    kind = 'EOF';\n    return;\n  }\n\n  start = end;\n\n  switch (code) {\n    // \"\n    case 34:\n      kind = 'String';\n      return readString();\n    // -, 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      kind = 'Number';\n      return readNumber();\n    // f\n\n    case 102:\n      if (string.slice(start, start + 5) !== 'false') {\n        break;\n      }\n\n      end += 4;\n      ch();\n      kind = 'Boolean';\n      return;\n    // n\n\n    case 110:\n      if (string.slice(start, start + 4) !== 'null') {\n        break;\n      }\n\n      end += 3;\n      ch();\n      kind = 'Null';\n      return;\n    // t\n\n    case 116:\n      if (string.slice(start, start + 4) !== 'true') {\n        break;\n      }\n\n      end += 3;\n      ch();\n      kind = 'Boolean';\n      return;\n  }\n\n  kind = string[start];\n  ch();\n}\n\nfunction readString() {\n  ch();\n\n  while (code !== 34 && code > 31) {\n    if (code === 92) {\n      // \\\n      ch();\n\n      switch (code) {\n        case 34: // \"\n\n        case 47: // /\n\n        case 92: // \\\n\n        case 98: // b\n\n        case 102: // f\n\n        case 110: // n\n\n        case 114: // r\n\n        case 116:\n          // t\n          ch();\n          break;\n\n        case 117:\n          // u\n          ch();\n          readHex();\n          readHex();\n          readHex();\n          readHex();\n          break;\n\n        default:\n          throw syntaxError('Bad character escape sequence.');\n      }\n    } else if (end === strLen) {\n      throw syntaxError('Unterminated string.');\n    } else {\n      ch();\n    }\n  }\n\n  if (code === 34) {\n    ch();\n    return;\n  }\n\n  throw syntaxError('Unterminated string.');\n}\n\nfunction readHex() {\n  if (code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 70 || // A-F\n  code >= 97 && code <= 102 // a-f\n  ) {\n      return ch();\n    }\n\n  throw syntaxError('Expected hexadecimal digit.');\n}\n\nfunction readNumber() {\n  if (code === 45) {\n    // -\n    ch();\n  }\n\n  if (code === 48) {\n    // 0\n    ch();\n  } else {\n    readDigits();\n  }\n\n  if (code === 46) {\n    // .\n    ch();\n    readDigits();\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    ch();\n\n    if (code === 43 || code === 45) {\n      // + -\n      ch();\n    }\n\n    readDigits();\n  }\n}\n\nfunction readDigits() {\n  if (code < 48 || code > 57) {\n    // 0 - 9\n    throw syntaxError('Expected decimal digit.');\n  }\n\n  do {\n    ch();\n  } while (code >= 48 && code <= 57); // 0 - 9\n\n}","map":null,"metadata":{},"sourceType":"script"}
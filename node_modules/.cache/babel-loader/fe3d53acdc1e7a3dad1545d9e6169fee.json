{"ast":null,"code":"const newline = /\\r?\\n/;\nconst onoCall = /\\bono\\b/;\n/**\n * Does a one-time determination of whether this JavaScript engine\n * supports lazy `Error.stack` properties.\n */\n\nexport const supportsLazyStack = Boolean( // ES5 property descriptors must be supported\nObject.getOwnPropertyDescriptor && Object.defineProperty && ( // Chrome on Android doesn't support lazy stacks :(\ntypeof navigator === \"undefined\" || !/Android/.test(navigator.userAgent)));\n/**\n * Does this error have a lazy stack property?\n */\n\nexport function hasLazyStack(error) {\n  if (!supportsLazyStack) {\n    return false;\n  }\n\n  let descriptor = Object.getOwnPropertyDescriptor(error, \"stack\");\n\n  if (!descriptor) {\n    return false;\n  }\n\n  return typeof descriptor.get === \"function\";\n}\n/**\n * Appends the original `Error.stack` property to the new Error's stack.\n */\n\nexport function joinStacks(newError, originalError) {\n  let newStack = popStack(newError.stack);\n  let originalStack = originalError ? originalError.stack : undefined;\n\n  if (newStack && originalStack) {\n    return newStack + \"\\n\\n\" + originalStack;\n  } else {\n    return newStack || originalStack;\n  }\n}\n/**\n * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.\n */\n\nexport function lazyJoinStacks(newError, originalError) {\n  let descriptor = Object.getOwnPropertyDescriptor(newError, \"stack\");\n\n  if (originalError && descriptor && typeof descriptor.get === \"function\") {\n    Object.defineProperty(newError, \"stack\", {\n      get: () => {\n        let newStack = descriptor.get.apply(newError);\n        return joinStacks({\n          stack: newStack\n        }, originalError);\n      },\n      enumerable: false,\n      configurable: true\n    });\n  } else {\n    lazyPopStack(newError);\n  }\n}\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n */\n\nfunction popStack(stack) {\n  if (stack === undefined) {\n    return undefined;\n  }\n\n  let lines = stack.split(newline);\n\n  if (lines.length < 2) {\n    // The stack only has one line, so there's nothing we can remove\n    return stack;\n  } // Find the `ono` call in the stack, and remove it\n\n\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i];\n\n    if (onoCall.test(line)) {\n      lines.splice(i, 1);\n      return lines.join(\"\\n\");\n    }\n  } // If we get here, then the stack doesn't contain a call to `ono`.\n  // This may be due to minification or some optimization of the JS engine.\n  // So just return the stack as-is.\n\n\n  return stack;\n}\n/**\n * Calls `popStack` lazily, when the `Error.stack` property is accessed.\n */\n\n\nfunction lazyPopStack(error) {\n  let descriptor = Object.getOwnPropertyDescriptor(error, \"stack\");\n\n  if (descriptor && typeof descriptor.get === \"function\") {\n    Object.defineProperty(error, \"stack\", {\n      get: () => popStack(descriptor.get.apply(error)),\n      enumerable: false,\n      configurable: true\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}
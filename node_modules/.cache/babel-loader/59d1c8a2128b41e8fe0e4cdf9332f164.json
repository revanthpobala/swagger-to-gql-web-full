{"ast":null,"code":"\"use strict\";\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst _require = require(\"ono\"),\n      ono = _require.ono;\n\nconst url = require(\"../util/url\");\n\nmodule.exports = {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   *\n   * @type {number}\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   *\n   * @type {object}\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   *\n   * @type {number}\n   */\n  timeout: 5000,\n  // 5 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   *\n   * @type {number}\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n   *\n   * @type {boolean}\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {boolean}\n   */\n  canRead(file) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   *\n   * @param {object} file           - An object containing information about the referenced file\n   * @param {string} file.url       - The full URL of the referenced file\n   * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @returns {Promise<Buffer>}\n   */\n  read(file) {\n    let u = url.parse(file.url);\n\n    if (process.browser && !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol = url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  }\n\n};\n/**\n * Downloads the given file.\n *\n * @param {Url|string} u        - The url to download (can be a parsed {@link Url} object)\n * @param {object} httpOptions  - The `options.resolve.http` object\n * @param {number} [redirects]  - The redirect URLs that have already been followed\n *\n * @returns {Promise<Buffer>}\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\n\nfunction download(u, httpOptions, redirects) {\n  return new Promise((resolve, reject) => {\n    u = url.parse(u);\n    redirects = redirects || [];\n    redirects.push(u.href);\n    get(u, httpOptions).then(res => {\n      if (res.statusCode >= 400) {\n        throw ono({\n          status: res.statusCode\n        }, \"HTTP ERROR \".concat(res.statusCode));\n      } else if (res.statusCode >= 300) {\n        if (redirects.length > httpOptions.redirects) {\n          reject(ono({\n            status: res.statusCode\n          }, \"Error downloading \".concat(redirects[0], \". \\nToo many redirects: \\n  \").concat(redirects.join(\" \\n  \"))));\n        } else if (!res.headers.location) {\n          throw ono({\n            status: res.statusCode\n          }, \"HTTP \".concat(res.statusCode, \" redirect with no location header\"));\n        } else {\n          // console.log('HTTP %d redirect %s -> %s', res.statusCode, u.href, res.headers.location);\n          let redirectTo = url.resolve(u, res.headers.location);\n          download(redirectTo, httpOptions, redirects).then(resolve, reject);\n        }\n      } else {\n        resolve(res.body || Buffer.alloc(0));\n      }\n    }).catch(err => {\n      reject(ono(err, \"Error downloading \".concat(u.href)));\n    });\n  });\n}\n/**\n * Sends an HTTP GET request.\n *\n * @param {Url} u - A parsed {@link Url} object\n * @param {object} httpOptions - The `options.resolve.http` object\n *\n * @returns {Promise<Response>}\n * The promise resolves with the HTTP Response object.\n */\n\n\nfunction get(u, httpOptions) {\n  return new Promise((resolve, reject) => {\n    // console.log('GET', u.href);\n    let protocol = u.protocol === \"https:\" ? https : http;\n    let req = protocol.get({\n      hostname: u.hostname,\n      port: u.port,\n      path: u.path,\n      auth: u.auth,\n      protocol: u.protocol,\n      headers: httpOptions.headers || {},\n      withCredentials: httpOptions.withCredentials\n    });\n\n    if (typeof req.setTimeout === \"function\") {\n      req.setTimeout(httpOptions.timeout);\n    }\n\n    req.on(\"timeout\", () => {\n      req.abort();\n    });\n    req.on(\"error\", reject);\n    req.once(\"response\", res => {\n      res.body = Buffer.alloc(0);\n      res.on(\"data\", data => {\n        res.body = Buffer.concat([res.body, Buffer.from(data)]);\n      });\n      res.on(\"error\", reject);\n      res.on(\"end\", () => {\n        resolve(res);\n      });\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}
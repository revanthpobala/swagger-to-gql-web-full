{"ast":null,"code":"const nonJsonTypes = [\"function\", \"symbol\", \"undefined\"];\nconst protectedProps = [\"constructor\", \"prototype\", \"__proto__\"];\nconst objectPrototype = Object.getPrototypeOf({});\n/**\n * Custom JSON serializer for Error objects.\n * Returns all built-in error properties, as well as extended properties.\n */\n\nexport function toJSON() {\n  // HACK: We have to cast the objects to `any` so we can use symbol indexers.\n  // see https://github.com/Microsoft/TypeScript/issues/1863\n  // tslint:disable: no-any no-unsafe-any\n  let pojo = {};\n  let error = this;\n\n  for (let key of getDeepKeys(error)) {\n    if (typeof key === \"string\") {\n      let value = error[key];\n      let type = typeof value;\n\n      if (!nonJsonTypes.includes(type)) {\n        pojo[key] = value;\n      }\n    }\n  } // tslint:enable: no-any no-unsafe-any\n\n\n  return pojo;\n}\n/**\n * Returns own, inherited, enumerable, non-enumerable, string, and symbol keys of `obj`.\n * Does NOT return members of the base Object prototype, or the specified omitted keys.\n */\n\nexport function getDeepKeys(obj, omit = []) {\n  let keys = []; // Crawl the prototype chain, finding all the string and symbol keys\n\n  while (obj && obj !== objectPrototype) {\n    keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));\n    obj = Object.getPrototypeOf(obj);\n  } // De-duplicate the list of keys\n\n\n  let uniqueKeys = new Set(keys); // Remove any omitted keys\n\n  for (let key of omit.concat(protectedProps)) {\n    uniqueKeys.delete(key);\n  }\n\n  return uniqueKeys;\n}","map":null,"metadata":{},"sourceType":"module"}
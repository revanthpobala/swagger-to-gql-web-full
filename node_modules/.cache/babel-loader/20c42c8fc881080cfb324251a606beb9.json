{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDiagnostics = getDiagnostics;\nexports.validateQuery = validateQuery;\nexports.getRange = getRange;\nexports.SEVERITY = void 0;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _graphql = require(\"graphql\");\n\nvar _graphqlLanguageServiceParser = require(\"graphql-language-service-parser\");\n\nvar _graphqlLanguageServiceUtils = require(\"graphql-language-service-utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n *  Copyright (c) 2019 GraphQL Contributors\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\n\nvar SEVERITY = {\n  ERROR: 1,\n  WARNING: 2,\n  INFORMATION: 3,\n  HINT: 4\n};\nexports.SEVERITY = SEVERITY;\n\nfunction getDiagnostics(query) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var customRules = arguments.length > 2 ? arguments[2] : undefined;\n  var isRelayCompatMode = arguments.length > 3 ? arguments[3] : undefined;\n  var ast = null;\n\n  try {\n    ast = (0, _graphql.parse)(query);\n  } catch (error) {\n    var range = getRange(error.locations[0], query);\n    return [{\n      severity: SEVERITY.ERROR,\n      message: error.message,\n      source: 'GraphQL: Syntax',\n      range: range\n    }];\n  }\n\n  return validateQuery(ast, schema, customRules, isRelayCompatMode);\n}\n\nfunction validateQuery(ast) {\n  var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var customRules = arguments.length > 2 ? arguments[2] : undefined;\n  var isRelayCompatMode = arguments.length > 3 ? arguments[3] : undefined; // We cannot validate the query unless a schema is provided.\n\n  if (!schema) {\n    return [];\n  }\n\n  var validationErrorAnnotations = mapCat((0, _graphqlLanguageServiceUtils.validateWithCustomRules)(schema, ast, customRules, isRelayCompatMode), function (error) {\n    return annotations(error, SEVERITY.ERROR, 'Validation');\n  }); // Note: findDeprecatedUsages was added in graphql@0.9.0, but we want to\n  // support older versions of graphql-js.\n\n  var deprecationWarningAnnotations = !_graphql.findDeprecatedUsages ? [] : mapCat((0, _graphql.findDeprecatedUsages)(schema, ast), function (error) {\n    return annotations(error, SEVERITY.WARNING, 'Deprecation');\n  });\n  return validationErrorAnnotations.concat(deprecationWarningAnnotations);\n} // General utility for map-cating (aka flat-mapping).\n\n\nfunction mapCat(array, mapper) {\n  return Array.prototype.concat.apply([], array.map(mapper));\n}\n\nfunction annotations(error, severity, type) {\n  if (!error.nodes) {\n    return [];\n  }\n\n  return error.nodes.map(function (node) {\n    var highlightNode = node.kind !== 'Variable' && node.name ? node.name : node.variable ? node.variable : node;\n    (0, _assert[\"default\"])(error.locations, 'GraphQL validation error requires locations.');\n    var loc = error.locations[0];\n    var highlightLoc = getLocation(highlightNode);\n    var end = loc.column + (highlightLoc.end - highlightLoc.start);\n    return {\n      source: \"GraphQL: \".concat(type),\n      message: error.message,\n      severity: severity,\n      range: new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(loc.line - 1, loc.column - 1), new _graphqlLanguageServiceUtils.Position(loc.line - 1, end))\n    };\n  });\n}\n\nfunction getRange(location, queryText) {\n  var parser = (0, _graphqlLanguageServiceParser.onlineParser)();\n  var state = parser.startState();\n  var lines = queryText.split('\\n');\n  (0, _assert[\"default\"])(lines.length >= location.line, 'Query text must have more lines than where the error happened');\n  var stream = null;\n\n  for (var i = 0; i < location.line; i++) {\n    stream = new _graphqlLanguageServiceParser.CharacterStream(lines[i]);\n\n    while (!stream.eol()) {\n      var style = parser.token(stream, state);\n\n      if (style === 'invalidchar') {\n        break;\n      }\n    }\n  }\n\n  (0, _assert[\"default\"])(stream, 'Expected Parser stream to be available.');\n  var line = location.line - 1;\n  var start = stream.getStartOfToken();\n  var end = stream.getCurrentPosition();\n  return new _graphqlLanguageServiceUtils.Range(new _graphqlLanguageServiceUtils.Position(line, start), new _graphqlLanguageServiceUtils.Position(line, end));\n}\n/**\n * Get location info from a node in a type-safe way.\n *\n * The only way a node could not have a location is if we initialized the parser\n * (and therefore the lexer) with the `noLocation` option, but we always\n * call `parse` without options above.\n */\n\n\nfunction getLocation(node) {\n  var typeCastedNode = node;\n  var location = typeCastedNode.loc;\n  (0, _assert[\"default\"])(location, 'Expected ASTNode to have a location.');\n  return location;\n}","map":null,"metadata":{},"sourceType":"script"}